# driver-exploitation-workbook

#Foreword

This is an extension of (perhaps a new chapter of?) the 0-day hunting workbook. Kernel exploitation is pretty neat - I like to think of the kernel as just another big ass program. If you look at it like that and have done any software exploitation, you'll be able to relate to the overall techniques used to exploit the kernel. Oftentimes when writing 'sploits we can get stuck in a mindset where we want that shell, that code execution, or whatever of our own writing. However, if you remember back when you were first learning, it was an important step to understand that all we are doing is controlling execution flow and manipulating/corrupting memory. Same with many CTFs (that guess the password game anybody?). When attacking the kernel we're going to be controlling its execution flow in a graceful way, we can't start clobbering anything because at the end of our exploit we need to continue normal operation. 

Kernel exploitation is where I like to start folks learning exploit writing because, ironically, it is arguably the least safe program on the operating system. If you've ever been a developer you know that WHAT to build and HOW to build it are extremely important. Now imagine scope creep, emergency features, emergency bug fixes, regular patching, major overhauls, splitting ad hoc into multiple projects seemingly at random. In fact there's no great definition of what the Windows kernel even really IS. Some people will argue that `HAL.dll` (hardware abstraction layer) is part of the kernel, others will say only ntoskrnl.exe (yep, .exe not .dll or .sys) is the real kernel. BUT WAIT, we have `kernel32.dll`, surely that's part of the kernel right? It even has the word kernel in it! Oh and what about `win32k.sys`!? Are those part of the kernel!?!? The answer is maybe. Hopefully this foreword has been the opposite of enlightening and left you extremely confused. Don't worry, all I'm getting at is that the kernel is a massive behemoth of a sprawling project that has way more than any single or even several Microsoft engineers could understand. This is great news for us, we just need a line or two of mistakes in this massive program and we can own the computer (ignoring Hypervisors for now).

But wait, MS has been working on this for like 40 years, surely exploitation can't be that easy!? In fact I've heard fancy words like control flow guard and SMEP!! The truth is, most OS protections just don't work in the kernel (like CFG) or are extremely easy to bypass (like SMEP). If you're not familiar with SMEP, think of it as a reverse access control, kernel-mode code can't touch user-space, but unfortunately most of the time no one cares. Fine, we won't touch userspace we'll just do everything at ring 0 as SYSTEM, darn, really foiled us this time. Anyway, in conclusion, a sad but good analogy for the kernel from a security perspective is an old ass PHP wordpress site with a bunch of plugins installed. Shake it a couple of times and your 0-days will fall out :-). Let's learn to shake.

#The HEVD, installation, and symbols

<placeholder>

#The coveted stack buffer overflow
  
We have the HEVD, we have our symbols, we're ready to rock. Since this isn't about 0-day hunting (that was the last workbook) I'll just give you the vulnerable IOCTL. Let's start with some crash triage so we laern to understand what we're looking at. At this point I pop open ioctlpus on the debugee:

![kernel_exploits_1_vm](https://user-images.githubusercontent.com/3106718/144956772-0f614c46-e2bb-4b25-a03b-a4ca91502724.PNG)

#Exercise 0x0
  
How tf did I get the name of the driver/path to put into ioctlpus? Hint: sysinternals.

Alright let's get on to the stack overflow. The IOCTLs are defined with friendly names here:
  
https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/HackSysExtremeVulnerableDriver.h
  
or
  
```
#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK                         IOCTL(0x800)
#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS                      IOCTL(0x801)
#define HEVD_IOCTL_ARBITRARY_WRITE                               IOCTL(0x802)
#define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL                IOCTL(0x803)
#define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL            IOCTL(0x804)
#define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL                 IOCTL(0x805)
#define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL                IOCTL(0x806)
#define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL           IOCTL(0x807)
#define HEVD_IOCTL_TYPE_CONFUSION                                IOCTL(0x808)
#define HEVD_IOCTL_INTEGER_OVERFLOW                              IOCTL(0x809)
#define HEVD_IOCTL_NULL_POINTER_DEREFERENCE                      IOCTL(0x80A)
#define HEVD_IOCTL_UNINITIALIZED_MEMORY_STACK                    IOCTL(0x80B)
#define HEVD_IOCTL_UNINITIALIZED_MEMORY_PAGED_POOL               IOCTL(0x80C)
#define HEVD_IOCTL_DOUBLE_FETCH                                  IOCTL(0x80D)
#define HEVD_IOCTL_INSECURE_KERNEL_FILE_ACCESS                   IOCTL(0x80E)
#define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL              IOCTL(0x80F)
#define HEVD_IOCTL_BUFFER_OVERFLOW_PAGED_POOL_SESSION            IOCTL(0x810)
#define HEVD_IOCTL_WRITE_NULL                                    IOCTL(0x811)
#define HEVD_IOCTL_BUFFER_OVERFLOW_NON_PAGED_POOL_NX             IOCTL(0x812)
#define HEVD_IOCTL_MEMORY_DISCLOSURE_NON_PAGED_POOL_NX           IOCTL(0x813)
#define HEVD_IOCTL_ALLOCATE_UAF_OBJECT_NON_PAGED_POOL_NX         IOCTL(0x814)
#define HEVD_IOCTL_USE_UAF_OBJECT_NON_PAGED_POOL_NX              IOCTL(0x815)
#define HEVD_IOCTL_FREE_UAF_OBJECT_NON_PAGED_POOL_NX             IOCTL(0x816)
#define HEVD_IOCTL_ALLOCATE_FAKE_OBJECT_NON_PAGED_POOL_NX        IOCTL(0x817)
#define HEVD_IOCTL_CREATE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX    IOCTL(0x818)
#define HEVD_IOCTL_SET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX  IOCTL(0x819)
#define HEVD_IOCTL_GET_ARW_HELPER_OBJECT_NAME_NON_PAGED_POOL_NX  IOCTL(0x81A)
#define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX    IOCTL(0x81B)
#define HEVD_IOCTL_ARBITRARY_INCREMENT                           IOCTL(0x81C)
```

Looks like the one we're looking for is:

`#define HEVD_IOCTL_BUFFER_OVERFLOW_STACK                         IOCTL(0x800)`

OK we cheated here and used source eh? Well this isn't really that unrealistic (except the names). Many times you'll have access to the source and if not a good reverser and DriverFuckBuddy (https://github.com/hyp3ri0n-ng/DriverFuckBuddy) should treat you right. Last resort is just brute forcing, and that's not so bad. So let's hit it.


